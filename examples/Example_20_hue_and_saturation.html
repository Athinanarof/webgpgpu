<html>
<script src="../lib/colormaps.js"></script>
<script src="../lib/gpgpu.js"></script>
<script src="../lib/gpugaussian.js"></script>
<script src="../lib/gpurand.js"></script>
<script src="../lib/complex_macros.js"></script>

<script id="huesaturation" type="x-shader/x-fragment">
// The long way:
// Convert from RGB to Hue Chroma Itensity space
// Rotate hue, scale Chroma,
// Convert back to RGB space
// This can be done (better) as three composed matrix operations
uniform sampler2D image;
uniform float hue;
uniform float saturation;
void main() {
    vec2 q = gl_FragCoord.xy/vec2(W,H); 
    vec3 c = texture2D(image,q).rgb;
    float alpha = dot(vec3(2,-1,-1),c);
    float beta  = dot(vec3(0,sqrt(3.0),-sqrt(3.0)),c);
    float gamma = dot(vec3(1,1,1),c);
    float coshue = cos(hue);
    float sinhue = sin(hue);
    float newalpha = (coshue*alpha + sinhue*beta)*saturation;
    float newbeta  = (coshue*beta  - sinhue*alpha)*saturation;
    vec3 HCrI = vec3(newalpha,newbeta,gamma);
    float newr = dot(vec3(2,0,2),HCrI);
    float newg = dot(vec3(-1,sqrt(3.0),2),HCrI);
    float newb = dot(vec3(-1,-sqrt(3.0),2),HCrI);
    gl_FragColor = vec4(newr,newg,newb,1.0)/6.0;
}
</script>

<script id="huesaturation2" type="x-shader/x-fragment">
// The short way: we can composit our color space transformations
// into a single 3x3 matrix and get a much simpler, faster shader
// unfortunately we need javascript to do the matrix math!
uniform sampler2D image;
uniform mat3 hcri_matrix;
void main() {
    vec2 q = gl_FragCoord.xy/vec2(W,H); 
    gl_FragColor = vec4(hcri_matrix*texture2D(image,q).rgb,1.0);
}
</script>


<script>
//Solution for monitoring the mouse location
//http://stackoverflow.com/questions/7790725/javascript-track-mouse-position
__mouse_location__ = {x:-1,y:-1};
(function() {
    document.onmousemove = handleMouseMove;
    function handleMouseMove(event) {
        __mouse_location__.x=event.pageX;
        __mouse_location__.y=event.pageY;
    }
})();

// To use color transform matrices, we'll need to be able to 
// compose matrix transformations CPUside
function multiplyMatrices(m1, m2) {
    var result = [];
    for (var i = 0; i < m1.length; i++) {
        result[i] = [];
        for (var j = 0; j < m2[0].length; j++) {
            var sum = 0;
            for (var k = 0; k < m1[0].length; k++) 
                sum += m1[i][k] * m2[k][j];
            result[i][j] = sum;
        }
    }
    return result;
}

// This is the main script that will run when the website loads
function main()
{
    // Get our example image (a tulip)
    // it has already been cropped to a square (a requirement for loading
    // images as textures for WebGL)
    tulip = new Image();
    tulip.src = 'tulip.png';
    tulip.onload = function(){

    // Retrieve a handle to the canvas element
    var canvas = $("maincanvas");
    
    // Get canvas location so we can find the mouse location
    var rect = canvas.getBoundingClientRect();

    // Create a WebGL context on the canvas, abort if fail
    var gl = getRasterGL(canvas);
    if (!gl) OUT; 
    // Convert image to tulip
    img       = image_texture(gl,tulip);
    huesaturation = getRasterProgram(gl,'huesaturation');
    huesaturation2 = getRasterProgram(gl,'huesaturation2');
    show      = GPUcopy(gl);
    show(img);
    
    // We can do the whole color transormation with 3x3 matrixes    
    // Matrix transformation from RGB to hue chroma intensity space
    var s3 = Math.sqrt(3.0);
    /*
    RGBtoHCRI = 
        [[2,-1,-1],
         [0,s3,-s3],
         [1, 1,1]];
    // Matrix transformation from hue chroma intensity space to RGB
    // TODO: compute inverse directly from RGBtoHCRI matrix? 
    HCRItoRGB = 
        [[2, 0,2],
        [-1,s3,2],
        [-1,s3,2]];
    for (var i=0; i<3; i++) for (var j=0; j<3; j++) HCRItoRGB[i][j]=HCRItoRGB[i][j]/6.0;
    */
    
    p_x = 0.0;
    p_y = 0.0;
    function animate() {
        setTimeout(function(){
            var nx = __mouse_location__.x-rect.left;
            var ny = __mouse_location__.y-rect.top;
            p_x = 0.7*p_x+0.3*nx;
            p_y = 0.7*p_y+0.3*ny;
            var x = p_x*2/gl.width-1;
            var y = p_y*2/gl.height-1;
            
            // We can recompute the color transform at every pixel
            // hue = Math.atan2(y,x);
            // saturation = Math.sqrt(x*x+y*y)*Math.sqrt(2.0);
            // huesaturation({image:img,hue:hue,saturation:saturation});

            // Or we can compute a color transformation on the CPU
            // and apply that quickly to each pixel
            // Matrix transformation for a rotation in HCrI space
            /*
            hue = Math.atan2(y,x);
            saturation = Math.sqrt(x*x+y*y)*Math.sqrt(2.0);
            ch = Math.cos(hue)*saturation;
            sh = Math.sin(hue)*saturation;
            HueSat = [
                [ ch,sh,0],
                [-sh,ch,0],
                [ 0 ,0 ,1]];
            color_matrix = multiplyMatrices(HCRItoRGB,multiplyMatrices(HueSat,RGBtoHCRI));
            color_matrix = [].concat.apply([], color_matrix);
            huesaturation2({image:img,hcri_matrix:color_matrix});            
            */
            
            // Or we can ask Wolfram alpha for the simplification of
            // {{2,-1,-1},{0,sqrt(3),-sqrt(3)},{1,1,1}}^-1 *
            // {{x,y,0},{-y,x,0},{0,0,1}} *
            // {{2,-1,-1},{0,sqrt(3),-sqrt(3)},{1,1,1}}
            // and get a magical answer that will be faster:
            var a = (0.25+x)/0.75;
            var y = y*2.0/s3;
            var x = (0.5-x)/1.5;
            var b = x+y;
            var c = x-y;
            color_matrix = [a,b,c,c,a,b,b,c,a];
            huesaturation2({image:img,hcri_matrix:color_matrix});       
            
            
            requestAnimationFrame(animate);
        },1000./120.);
    }
    animate();
    };
}
</script>
<body onload="javascript:main()">
<canvas id='maincanvas' style="width:512px;height:512px;"></canvas>
</body>
</html>
