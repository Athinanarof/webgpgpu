<html>
<script src="../lib/colormaps.js"></script>
<script src="../lib/gpgpu.js"></script>

<script id="blur" type="x-shader/x-fragment">
// Gaussian blue in X or Y directions
// Variables W, H, K, AX will be defined later when shader is compiled
#define XY gl_FragCoord.xy
uniform   sampler2D data;
uniform   float     weights[K+1];
void main() {
    vec2 scale = 1./vec2(W,H);
    vec4 c = texture2D(data,XY*scale);
    for (int i=1; i<=K; i++)
        c += (
            texture2D(data,(XY+vec2( i*(1-AX), i*AX))*scale)+
            texture2D(data,(XY+vec2(-i*(1-AX),-i*AX))*scale))
            * weights[i];
    gl_FragColor = c/c.a;
}
</script>

<script id="draw-input" type="x-shader/x-fragment">
void main() {
    float cx = mod(floor(gl_FragCoord.x/64.),2.);
    float cy = mod(floor(gl_FragCoord.y/64.),2.);
    float chex = mod(cx+cy,2.);
    gl_FragColor = vec4(chex,chex,chex,1);
}
</script>

<script id="show" type="x-shader/x-fragment">
// copies a texture buffer to screen
// Variables W, H will be defined later when shader is compiled
uniform   sampler2D data;
void main() {
    vec2 scale = 1./vec2(W,H);
    gl_FragColor = texture2D(data,gl_FragCoord.xy*scale);
}
</script>

<script id="noise" type="x-shader/x-fragment">
// Use chaos to get some amount of noise
// This is experimental and likely has very poor numeric properties
// Can't really use integers since overflow saturates, you lose some of the nice
// properties of the ring.
#define XY gl_FragCoord.xy
uniform   sampler2D data;
void main() {
    vec2 scale = 1./vec2(W,H);
    vec4 c0 = texture2D(data,(XY+vec2( 0, 0))*scale);
    vec4 c1 = texture2D(data,(XY+vec2( 0, 1))*scale);
    vec4 c2 = texture2D(data,(XY+vec2( 1, 0))*scale);
    vec4 c3 = texture2D(data,(XY+vec2(-1, 0))*scale);
    vec4 c4 = texture2D(data,(XY+vec2( 0,-1))*scale);
    //gl_FragColor = mod(
    //    vec4(c0*251+c1*241+c2*239+c3*233+c4*229+227)*0.000000390625,1.);
    //gl_FragColor = vec4(.5,0,0,1);
    vec3 color = mod((c0+c1+c2+c3+c4+3.1415923485).rgb*8.8857658763167322,1.0);
    gl_FragColor = vec4(color,1.);
}
</script>

<script id="average" type="x-shader/x-fragment">
#define XY gl_FragCoord.xy
uniform   sampler2D A;
uniform   sampler2D B;
void main() {
    vec2 scale = 1./vec2(W,H);
    vec4 c0 = texture2D(A,(XY+vec2( 0, 0))*scale);
    vec4 c1 = texture2D(B,(XY+vec2( 0, 0))*scale);
    vec4 alpha = vec4(1.,1.,1.,0)*ALPHA*c1.a*100.;
    gl_FragColor = vec4((c1*alpha+c0*(100.-alpha)).rgb*.01,1.);
}
</script>

<script id="contrast" type="x-shader/x-fragment">
#define XY gl_FragCoord.xy
uniform   sampler2D data;
uniform   float gain;
void main() {
    vec2 scale = 1./vec2(W,H);
    vec3 c = texture2D(data,(XY+vec2( 0, 0))*scale).rgb;
    gl_FragColor = vec4(vec3(1./(1.0+exp(gain*(2.-c*4.)))),1.);
}
</script>

<script>

/**
 * Initialize a Guassian convolution kernel
 * @param sigma {float} - positive floating point value for standard deviation
 * @return {Float32Array} - additional fields width and radius are stored too.
 */
function createGaussianKernel(sigma,normalized) {
    // Prepare kernel
    var radius = Math.ceil(3*sigma);
    var kernel = new Float32Array(radius+1);
    kernel.radius = radius;
    var sum = 0.;
    for (var i=0; i<=radius; i++)
        sum += kernel[i] = 100*Math.exp(-0.5*Math.pow(i/sigma,2));
    if (normalized) for (var i=0; i<length; i++) kernel[i] /= sum;
    return kernel;
}

// This is the main script that will run when the website loads
function main()
{
    // Retrieve a handle to the canvas element
    var canvas = $("maincanvas");

    // Create a WebGL context on the canvas, abort if fail
    var gl = getRasterGL(canvas);
    if (!gl) OUT;

    var kernel = createGaussianKernel(1);

    var buffer1 = newBasicFramebuffer(gl,{wrap : gl.REPEAT});
    var buffer2 = newBasicFramebuffer(gl,{wrap : gl.REPEAT});
    var noise1  = newBasicFramebuffer(gl,{wrap : gl.REPEAT});
    var noise2  = newBasicFramebuffer(gl,{wrap : gl.REPEAT});
    var output  = newBasicFramebuffer(gl);

    var render  = getRasterProgram(gl,'draw-input');
    var copy    = getRasterProgram(gl,'show');
    var noise   = getRasterProgram(gl,'noise');
    var contrast   = getRasterProgram(gl,'contrast');
    var average = getRasterProgram(gl,'average',{
        ALPHA : '0.1'
    });
    var blur_x  = getRasterProgram(gl,'blur',{
        K  : kernel.radius,
        AX : 0
    });
    var blur_y  = getRasterProgram(gl,'blur',{
        K  : kernel.radius,
        AX : 1
    });

    var rand = Math.floor(Math.random()*0x1000000);
    function seedrand() {
        rand = Math.floor(Math.random()*0x1000000);}
    function weakrand() {
        return (rand^=rand>>2^rand<<1)&0xff;}
    function randomize(texture) {
        if (texture.hasOwnProperty('texture')) texture = texture.texture;
        var W = texture.width;
        var H = texture.height;
        var L = 4*W*H;
        var noise = new Uint8Array(L);
        for (var i=0;i<L;++i) noise[i] = weakrand();
        console.log(texture);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,W,H,
            gl.RGBA,gl.UNSIGNED_BYTE,noise);
    }

    randomize( noise1 );
    randomize( buffer1 );

    function animate() {
        setTimeout(function(){
            noise ( {data:noise1}, output );
            copy( {data:output}, noise1 );
            blur_x( {weights:kernel, data:buffer1}, buffer2 );
            blur_y( {weights:kernel, data:buffer2}, buffer1 );
            average( {A:buffer1, B:noise1}, output);
            contrast( {data:output,gain:1.1}, buffer2 );
            copy( {data:buffer2}, buffer1);

            contrast( {data:buffer1,gain:5}, output );
            copy( {data:output} );
            requestAnimationFrame(animate);
        },1000./60.);
    }
    animate();

}
</script>
<body onload="javascript:main()">
<canvas id='maincanvas' style="width:512px;height:512px;"></canvas>
</body>
</html>
