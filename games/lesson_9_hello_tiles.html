<!DOCTYPE html>
<html>
<meta charset="utf-8"/>
<!--
- Fill the screen with the game environment. No scrolling
- Top portion of screen is game panel, bottom region console
- Set up a basic web GL canvas environment that we'll use to draw the game
- Move setup code into a library ("gpgpu")
- Add bounded rendering region, with view scale and coordinates
- Add mouse control: drag to pan, scroll wheel to zoom in/out
- Add keyboard control: arrow keys to pan; +/- PgUp/PgDn to zoom
- Render an image from texture using nearest-neighbor interpolation
- Create a 2D game environment based on square tiles

This requires defining another rendering layer that computes a tile index, which
is then passed to the final renderer to generate the visible screen. 

We create this as another WebGL texture "tile_ids"

For an initial demonstration, we combine this with a random number generator
to randomly shuffle the visible tiles. 

Useful
https://webgl2fundamentals.org/webgl/lessons/webgl-anti-patterns.html
https://stackoverflow.com/questions/13870677/resize-viewport-canvas-according-to-browser-window-size
https://github.com/michaelerule/webgpgpu
https://stackoverflow.com/a/7732968/900749
https://www.w3schools.com/js/js_htmldom_events.asp
https://javascript.info/introduction-browser-events
https://developer.mozilla.org/en-US/docs/Web/Events
https://stackoverflow.com/a/11183302/900749
https://stackoverflow.com/a/11183333/900749
https://www.javascripttutorial.net/javascript-dom/javascript-keyboard-events/
https://github.com/michaelerule/webgpgpu/blob/master/examples/Example_15_load_image.html
https://webglfundamentals.org/webgl/lessons/webgl-cors-permission.html
https://stackoverflow.com/questions/21540520/how-to-perform-mipmapping-in-webgl
-->
<head>
<script>
window.addEventListener('load', function() {
    load_textures();
})
</script>
<script src="./lib/gpgpu.js"></script>
<script src="./lib/gpurand.js"></script>
<script src="./lib/parameters.js"></script>
<script src="./user_event_handlers.js"></script>
<script src="./webgl_game_initialization_helpers.js"></script>
<script src="./base64_encoded_textures.js"></script>
<link rel="stylesheet" type="text/css" href="lessons.css">
</head>
<body>
<div id="outer_container">
<div id="controls_top"></div>
<canvas id="game_canvas"></canvas>
<div id="controls_bottom"></div>
</div>

<!--Tile shader: render 2D tiles using 8-bit ID passed as texture R channel-->
<script id="tile_shader_parameters" type="x-shader/x-fragment">
sampler2D tiles;
sampler2D tile_ids;
vec2  game_size;
vec2  screen_size;
vec2  texture_size;
vec2  tile_size;
float tiles_across;
vec3  view_transform;
</script>
<script id="tile_shader" type="x-shader/x-fragment">
#define RED    vec4(1.0,0.0,0.0,0.0)
#define GREEN  vec4(0.0,1.0,0.0,0.0)
#define BLUE   vec4(0.0,0.0,1.0,0.0)
#define VIOLET vec4(1.0,0.0,1.0,0.0)
#define DEBUG  true
void main() {
    // Transform from screen coordinates to game pixel coordinates
    vec2 q = gl_FragCoord.xy;
    vec2 p = gl_FragCoord.xy*view_transform.z + view_transform.xy;
    // Exit if coordinate is not inside visible game region
    gl_FragColor = vec4(0.2,0.2,0.2,0.0);
    if (p.x<0.0||p.y<0.0||p.x>screen_size.x||p.y>screen_size.y) return;
    // Get tile info: use red channel to decode a tile ID from 0-255
    float id = 255.0-floor(texture2D(tile_ids,p/screen_size).r*255.0);
    // Convert tile ID to tile position in texture
    vec2 txy = vec2(mod(id,tiles_across),floor(id/tiles_across));
    // Calculate pixel offset into the tile
    vec2 tdelta = floor(mod(p,tile_size));
    // Coordinates are a bit weird, fix this.
    txy.x = tiles_across-1.0-txy.x;
    // This is our tile pixel lookup in pixels
    vec2 w = txy*tile_size + tdelta;
    // Divide by texture size to get correct coordinate
    gl_FragColor = texture2D(tiles,w/(float(tiles_across)*tile_size));
    if (DEBUG) {
        // Render a 1 pixel grid at both game and screen scales
        // Shade game pixels at the edge of each tile
        vec2 o = floor(mod(p,tile_size));
        if (o.x==0.0||o.y==0.0)
            gl_FragColor = (VIOLET+gl_FragColor)*0.5;
        if (o.x==tile_size.x-1.0||o.y==tile_size.y-1.0)
            gl_FragColor = (BLUE+gl_FragColor)*0.5;
        if (mod(q.x,2.0)!=mod(q.y,2.0)) {
            // Shade screen pixels at the edge of each tile
            // Depending on scale, sctsz can take on fractional values
            vec2 sctsz = tile_size/view_transform.z;
            // Start of each screen tile
            o = floor(mod(q+view_transform.xy/view_transform.z,sctsz));
            if (o.x==0.0||o.y==0.0) gl_FragColor = GREEN;
            // End of each screen tile
            o = floor(mod(q+1.0+view_transform.xy/view_transform.z,sctsz));
            if (o.x==0.0||o.y==0.0) gl_FragColor = RED;
        }
        if (p.x<0.0||p.y<0.0||p.x>=screen_size.x||p.y>=screen_size.y) gl_FragColor*=0.25;
    }
}
</script>
<script>
// Configuration constants.
// The game size is now defined in terms of tiles. 
const game_w_tiles = 80;
const game_h_tiles = 48;
// We need to know shape of tiles in the tiles texture, as well as
// how many tiles across it is
const tile_w_px    = 8;
const tile_h_px    = 8;
const tiles_across = 16;
// Calculated game shape in pixels
const game_w_px    = game_w_tiles*tile_w_px;
const game_h_px    = game_h_tiles*tile_h_px;
// View behavior and limits
const max_scale    = 8;
const min_scale    = 2;
const key_pan      = 10;
const key_zoom     = 1.1;
// Global variables (mutable)
var game_focus_x = game_w_px/2;
var game_focus_y = game_h_px/2;
var game_scale   = 2.0;
/**
 * Render game on canvas using current canvas size, scale, and focus point. 
 */
function render() {
    var w = gl.canvas.width;
    var h = gl.canvas.height;
    gl.viewport(0,0,w,h);
    var s = 1.0/game_scale;
    var x = Math.floor(game_focus_x-w/2*s);
    var y = Math.floor(game_focus_y-h/2*s);
    tile_shader({tiles:texture,tile_ids:noise,view_transform:[x,y,s]});
    console.log("Rendered");
};
/** 
 * Main script that will run when the website loads
 */
function main() {
    canvas = init_webgl_canvas();
    gl = canvas.gl;
    // Compile shader with new constants needed to index into the tiles texture
    tile_shader = bind_program(gl,"tile_shader",{
        game_size   :[game_w_tiles,game_h_tiles],
        tile_size   :[tile_w_px,tile_h_px],
        screen_size :[game_w_px,game_h_px],
        tiles_across:tiles_across});
    // Create tiles texture
    texture = pixel_art_texture(gl,tiles);
    // Make some noise (random tile ID values)
    noise  = newBasicFramebuffer(gl,{
        width:game_w_tiles, 
        height:game_h_tiles, 
        mag_filter:gl.NEAREST, 
        min_filter:gl.LINEAR, 
        wrap:gl.CLAMP_TO_EDGE});
    randomize_framebuffer(noise);
    // Set up UI and start.
    add_event_listeners();
    resizeCanvas();
    scale_to_screen();
    render();
    console.log("Loaded");
}
/**
 * Load tiles image from base64 string.
 * We wait until the image loads before initializing the WebGL environment.
 * We achieve this by calling main() from the textures "onload" callback.
 */
function load_textures() {
    tiles = new Image();
    tiles.crossOrigin = "anonymous";
    tiles.onload = main;
    tiles.src = base64_textures.tiles;
}
</script>
</body>
</htlm>
